import React, { useEffect, useMemo, useRef, useState } from "react";
import StarsRow from "./StarsRow";
import Confetti from "./Confite";
import TitleScreen from "./TitleScreen";
import Loader from "./Loader";

// ======== Config ========
const ROWS = 8;
const COLS = 12;
const CARD_GRADS = [
  // "linear-gradient(135deg,#fef3c7,#fde68a)",
  // "linear-gradient(135deg,#e9d5ff,#c4b5fd)",
  // "linear-gradient(135deg,#bfdbfe,#93c5fd)",
  // "linear-gradient(135deg,#fecaca,#fda4af)",
  // "linear-gradient(135deg,#fde68a,#fcd34d)",
  // "linear-gradient(135deg,#fbcfe8,#f9a8d4)",
  // "linear-gradient(135deg,#a7f3d0,#6ee7b7)",
  // "linear-gradient(135deg,#fde68a,#fca5a5)",
  // "linear-gradient(135deg,#c7d2fe,#a5b4fc)"
];
const ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

// ======== Test Data for Testing Purposes ========
const testDataSet = {
  word_list: [
    {
      data_set_id: 1,
      words: ["APPLE", "BANANA", "GRAPE", "MANGO", "PEACH","SMART","VOCABULARY",'DATASET']
    }
  ]
};

// ======== Utils ========
const shuffle = (arr) => {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
};

<Loader/>

function generatePuzzleFromSet(words) {
  const grid = Array.from({ length: ROWS }, () => Array(COLS).fill(""));
  const placed = [];

  const chosen = shuffle(words).slice(0, 8);
  const diagCount = Math.max(1, Math.min(2, chosen.length >= 8 ? 2 : 1));
  const diagWords = chosen.slice(0, diagCount);
  const straightWords = chosen.slice(diagCount);

  for (const w of diagWords) {
    if (!placeWord(grid, w, placed, ["diagDR", "diagDL"])) {
      console.warn(`Could not place diagonal word: ${w}, retrying with new grid`);
      return generatePuzzleFromSet(words);
    }
  }
  for (const w of straightWords) {
    if (!placeWord(grid, w, placed, ["across", "down"])) {
      console.warn(`Could not place straight word: ${w}, retrying with new grid`);
      return generatePuzzleFromSet(words);
    }
  }

  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++)
      if (!grid[r][c]) grid[r][c] = ALPHA[Math.floor(Math.random() * 26)];

  return { grid, words: chosen, placed };
}

function placeWord(grid, word, placed, allowedDirs = ["across", "down", "diagDR", "diagDL"]) {
  const dirs = shuffle(allowedDirs);
  for (const dir of dirs) {
    let maxR = ROWS - 1, maxC = COLS - 1, minR = 0, minC = 0;
    if (dir === "down") { maxR = ROWS - word.length; }
    if (dir === "across") { maxC = COLS - word.length; }
    if (dir === "diagDR") { maxR = ROWS - word.length; maxC = COLS - word.length; }
    if (dir === "diagDL") { maxR = ROWS - word.length; minC = word.length - 1; maxC = COLS - 1; }

    if (word.length > Math.max(ROWS, COLS)) continue;

    for (let t = 0; t < 500; t++) {
      const r0 = Math.floor(Math.random() * (maxR - minR + 1)) + minR;
      const c0 = Math.floor(Math.random() * (maxC - minC + 1)) + minC;
      let ok = true;
      for (let i = 0; i < word.length; i++) {
        const r = r0 + (dir === "down" || dir === "diagDR" || dir === "diagDL" ? i : 0);
        const c = c0 + (dir === "across" || dir === "diagDR" ? i : 0) + (dir === "diagDL" ? -i : 0);
        if (r < 0 || r >= ROWS || c < 0 || c >= COLS) {
          ok = false;
          break;
        }
        const ch = grid[r][c];
        if (ch && ch !== word[i]) {
          ok = false;
          break;
        }
      }
      if (!ok) continue;
      for (let i = 0; i < word.length; i++) {
        const r = r0 + (dir === "down" || dir === "diagDR" || dir === "diagDL" ? i : 0);
        const c = c0 + (dir === "across" || dir === "diagDR" ? i : 0) + (dir === "diagDL" ? -i : 0);
        grid[r][c] = word[i];
      }
      placed.push({ word, dir, r0, c0, len: word.length });
      return true;
    }
  }
  console.warn(`Failed to place word: ${word}`);
  return false;
}

function useViewportSize() {
  const [vp, setVp] = useState({ w: window.innerWidth, h: window.innerHeight });
  useEffect(() => {
    const onR = () => setVp({ w: window.innerWidth, h: window.innerHeight });
    window.addEventListener("resize", onR);
    return () => window.removeEventListener("resize", onR);
  }, []);
  return vp;
}

function buildPath(a, b) {
  const path = [];
  if (!b) return path;
  if (a.r === b.r) {
    const [c1, c2] = a.c < b.c ? [a.c, b.c] : [b.c, a.c];
    for (let c = c1; c <= c2; c++) path.push({ r: a.r, c });
  } else if (a.c === b.c) {
    const [r1, r2] = a.r < b.r ? [a.r, b.r] : [b.r, a.r];
    for (let r = r1; r <= r2; r++) path.push({ r, c: a.c });
  } else if (Math.abs(a.r - b.r) === Math.abs(a.c - b.c)) {
    const steps = Math.abs(a.r - b.r);
    const dr = b.r > a.r ? 1 : -1;
    const dc = b.c > a.c ? 1 : -1;
    for (let i = 0; i <= steps; i++) path.push({ r: a.r + i * dr, c: a.c + i * dc });
  }
  return path;
}

// ======== Component ========
export default function WordSearchA1() {
  const [screen, setScreen] = useState("title");
  const [levelIdx, setLevelIdx] = useState(0);
  const [toolData, setToolData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [currentSet, setCurrentSet] = useState(null);
  const [puzzle, setPuzzle] = useState(null);
  const [found, setFound] = useState(() => new Set());
  const [rings, setRings] = useState([]);
  const [drag, setDrag] = useState(null);
  const [elapsed, setElapsed] = useState(0);
  const [celebrate, setCelebrate] = useState(false);
  // const [seconds, setSeconds] = useState(0);
  // const [timerActive, setTimerActive] = useState(false);
  const startTimeRef = useRef(null);
  const [displayTime, setDisplayTime] = useState(0); // optional: live timer UI
const timerIntervalRef = useRef(null);

  const svgRef = useRef(null);
  const { w: vw, h: vh } = useViewportSize();
  const isMobile = vw < 640;
  const isTablet = vw >= 640 && vw < 1010;
  const padding = 16,
        gap = 12,
        timeBar = 28;
  const sideW = isMobile ? vw - padding * 2 : isTablet ? 200 : Math.max(220, Math.min(320, Math.floor(vw * 0.26)));
  const availW = isMobile ? vw - padding * 2 : vw - padding * 2 - sideW - gap;
  const availH = vh - padding * 2 - timeBar;

  const cellPx = Math.floor(Math.min(availW / COLS, availH / ROWS));
  const boardW = cellPx * COLS;
  const boardH = cellPx * ROWS;

  const hasValidData = toolData && toolData.word_list?.[0]?.words?.length > 0;

  const startTimer = () => {
  startTimeRef.current = Date.now();

  // Optional: live timer display
  timerIntervalRef.current = setInterval(() => {
    setDisplayTime(Math.floor((Date.now() - startTimeRef.current) / 1000));
  }, 1000);
};

const stopTimer = () => {
  if (timerIntervalRef.current) {
    clearInterval(timerIntervalRef.current);
    timerIntervalRef.current = null;
  }
};


  // Timer for elapsed time
  // useEffect(() => {
  //   let interval;
  //   if (timerActive) {
  //     interval = setInterval(() => setSeconds((prev) => prev + 1), 1000);
  //   }
  //   return () => clearInterval(interval);
  // }, [timerActive]);

  const correctAudio = useMemo(
    () => new Audio("https://d3g74fig38xwgn.cloudfront.net/sound_wall/sounds/correct-answer.mp3"),
    []
  );

  useEffect(() => {
    correctAudio.load();
  }, [correctAudio]);

  // Initialize puzzle with testDataSet or backend data via window.wordSearchTool
  useEffect(() => {
  //   setLoading(true);
  //   // For testing, initialize with testDataSet
  //   // setToolData(testDataSet);
  //   // setCurrentSet(testDataSet);
  //   // setPuzzle(generatePuzzleFromSet(testDataSet.word_list[0].words));
  //   // setLoading(false);

  //   // Production: Set up window.wordSearchTool to receive backend data
    window.wordSearchTool = (data) => {
      console.log("window.wordSearchTool received data:", data);
      if (
        data &&
        data.data_set &&
        Array.isArray(data.data_set) &&
        data.data_set[0] &&
        data.data_set[0].word_list &&
        Array.isArray(data.data_set[0].word_list) &&
        data.data_set[0].word_list[0]?.words?.length > 0
      ) {
        const filteredData = {
          word_list: [
            {
              ...data.data_set[0].word_list[0],
              words: data.data_set[0].word_list[0].words.filter((word) => word.length <= 10),
            }
          ],
        };
        setToolData(filteredData);
        setCurrentSet(filteredData);
        setPuzzle(generatePuzzleFromSet(filteredData.word_list[0].words));
        setLoading(false);
      } else {
        console.error("Invalid toolData structure:", data);
        setToolData(null);
        setCurrentSet(null);
        setPuzzle(null);
        setLoading(false);
      }
    };
    return () => {
      window.wordSearchTool = undefined;
    };
  }, []);
  // testing ----
  // Replace your initialization useEffect with this:
// useEffect(() => {
//   setLoading(true);
  
//   // Set up the callback immediately
//   window.wordSearchTool = (data) => {
//     console.log("Received data:", data);
    
//     // Handle both possible data structures
//     let words = [];
    
//     if (data?.data_set?.[0]?.word_list?.[0]?.words) {
//       words = data.data_set[0].word_list[0].words;
//     } else if (data?.word_list?.[0]?.words) {
//       words = data.word_list[0].words;
//     }
    
//     if (words.length > 0) {
//       const filteredData = {
//         word_list: [{
//           data_set_id: 1,
//           words: words.filter(word => word && word.length <= 10)
//         }]
//       };
      
//       setToolData(filteredData);
//       setCurrentSet(filteredData);
//       setPuzzle(generatePuzzleFromSet(filteredData.word_list[0].words));
//     } else {
//       // Fallback to test data
//       // setToolData(testDataSet);
//       // setCurrentSet(testDataSet);
//       // setPuzzle(generatePuzzleFromSet(testDataSet.word_list[0].words));
//     }
    
//     setLoading(false);
//   };

//   // For testing, use test data immediately
//   window.wordSearchTool(testDataSet);
  
//   return () => {
//     window.wordSearchTool = undefined;
//   };
// }, []);

  // Update puzzle when level changes
  useEffect(() => {
    if (!toolData || !hasValidData || !currentSet) return;
    setPuzzle(generatePuzzleFromSet(currentSet.word_list[0].words));
    setFound(new Set());
    setRings([]);
    setElapsed(0);
    setCelebrate(false);
    setLoading(false);
  }, [toolData, levelIdx, currentSet, hasValidData]);

  // Timer for game progress
  useEffect(() => {
    if (screen !== "play") return;
    const id = setInterval(() => setElapsed((e) => e + 100), 100);
    return () => clearInterval(id);
  }, [screen]);

  // Check if puzzle is finished
  const finished = useMemo(() => puzzle && puzzle.words.length > 0 && found.size === puzzle.words.length, [puzzle, found]);
  useEffect(() => {
    if (!finished) return;
    setCelebrate(true);
    stopTimer();
  }, [finished]);

  const onDown = (r, c) => setDrag({ active: true, start: { r, c }, end: { r, c } });
  const onEnter = (r, c) => setDrag((d) => (d?.active ? { ...d, end: { r, c } } : d));
  const onUp = () => {
    if (!drag?.active || !puzzle) return;
    const { start, end } = drag;
    if (!start || !end) {
      setDrag(null);
      return;
    }
    const isStraight = start.r === end.r || start.c === end.c;
    const isDiag = Math.abs(start.r - end.r) === Math.abs(start.c - end.c);
    const forward = end.r >= start.r;

    if ((isStraight || isDiag) && forward) {
      const path = buildPath(start, end);
      const text = path.map(({ r, c }) => puzzle.grid[r][c]).join("");
      const hit = puzzle.words.find((w) => !found.has(w) && w === text);
      if (hit) {
        setFound((s) => new Set([...s, hit]));
        correctAudio.currentTime = 0;
        correctAudio.play().catch((err) => console.error("Correct audio error:", err));
        if (isDiag) {
          setRings((rs) => [
            ...rs,
            ...path.map(({ r, c }, i) => ({ x: c, y: r, w: 1, h: 1, id: `diag-${hit}-${i}-${r}-${c}` })),
          ]);
        } else {
          const x = Math.min(start.c, end.c),
                y = Math.min(start.r, end.r);
          const w = start.r === end.r ? path.length : 1,
                h = start.c === end.c ? path.length : 1;
          setRings((rs) => [...rs, { x, y, w, h, id: `rect-${x}-${y}-${w}-${h}-${hit}` }]);
        }
      }
    }
    setDrag(null);
  };

  // Fetch new words by triggering backend
  const fetchNewWords =  (data_set_id,level) => {
    console.log('i caling')
    setLoading(true);
    try {
      console.log('i func caling')
      const formData = new FormData();
      formData.append("data_set_id", data_set_id);
      formData.append("level", level);
      formData.append("status", "completed");
      console.log("Calling window.wordSearchTool with data_set_id:", data_set_id, "status: completed");
       window.gettingWordSearchData(formData);
      // For testing: Simulate backend response and trigger window.wordSearchTool
      const mockResponse = {
        data_set: [
          {
            word_list: [
              {
                data_set_id: data_set_id + 1,
                words: ["RIVER", "MOUNTAIN", "FOREST", "OCEAN", "VALLEY"]
              }
            ]
          }
        ]
      };
      // window.wordSearchTool(mockResponse);
      console.log("Simulated window.wordSearchTool with mock response");

      // Production: Trigger backend to call window.wordSearchTool

      // Wait briefly to ensure window.wordSearchTool has processed
       new Promise((resolve) => setTimeout(resolve, 100));
      console.log("toolData after fetch:", toolData);
      if (toolData && toolData.word_list && toolData.word_list[0].words) {
        return toolData;
      } else {
        throw new Error("No valid data received");
      }
    } catch (err) {
      console.error("Error fetching new words:", err);
      setScreen("title");
      return null;
    } finally {
      setLoading(false);
    }
  };

  // Submit timespent
  // const submitTimespent = (data_set_id,level) => {
  //   const formData = new FormData();
  //   formData.append("data_set_id", data_set_id);
  //   formData.append("level", level);
  //   formData.append("status", "completed");
  //   formData.append("timespent", timespent);
  //   try {
  //     window.wordsearchtimespent(formData);
  //     console.log("Timespent submitted:", { data_set_id, timespent, status: "completed" });
  //   } catch (err) {
  //     console.error("Error submitting timespent:", err);
  //   }
  // };
const submitTimespent = (data_set_id, level) => {
  if (!startTimeRef.current) return;

  const finalTime = Math.floor((Date.now() - startTimeRef.current) / 1000);

  const formData = new FormData();
  formData.append("data_set_id", data_set_id);
  formData.append("level", level);
  formData.append("status", "completed");
  formData.append("timespent", finalTime);

  try {
    window.wordsearchtimespent(formData);
    console.log("Timespent submitted:", finalTime);
  } catch (err) {
    console.error("Error submitting timespent:", err);
  }
};



  // Handle Next button
  // const handleNextLevel = async () => {
  //   if (!currentSet) {
  //     console.error("No currentSet available");
  //     setLoading(false);
  //     return;
  //   }
  //   setLoading(true);
  //   setCelebrate(false);
  //   const level =currentSet.word_list[0].level
  //   const currentDataSetId = currentSet.word_list[0].data_set_id;
  //   console.log("handleNextLevel: Submitting timespent for data_set_id:", currentDataSetId);
  //   submitTimespent(currentDataSetId, seconds,level);

  //   console.log("handleNextLevel: Fetching new words for data_set_id:", currentDataSetId);
  //   // const newData = await fetchNewWords(currentDataSetId);
  //   // fetchNewWords(currentDataSetId);
  //   const newData = await fetchNewWords(currentDataSetId,level);

  //   console.log("handleNextLevel: Received newData:", newData);
  //   if (newData) {
  //     setLevelIdx((prev) => {
  //       console.log("handleNextLevel: Incrementing levelIdx to:", prev + 1);
  //       return prev + 1;
  //     });
  //     setPuzzle(generatePuzzleFromSet(newData.word_list[0].words));
  //     setFound(new Set());
  //     setRings([]);
  //     setElapsed(0);
  //     setSeconds(0);
  //     setTimerActive(true);
  //   }
  //   setLoading(false);
  // };
const handleNextLevel = async () => {
  if (!currentSet) return;

  const level = currentSet.word_list[0].level;
  const currentDataSetId = currentSet.word_list[0].data_set_id;

  // Submit time for this level
  submitTimespent(currentDataSetId, level);

  setCelebrate(false);
  setLoading(true);

  const newData = await fetchNewWords(currentDataSetId, level);

  if (newData) {
    setLevelIdx((prev) => prev + 1);
    setPuzzle(generatePuzzleFromSet(newData.word_list[0].words));
    setFound(new Set());
    setRings([]);

    // âœ… Reset and start timer for next level
    stopTimer(); 
    startTimer();
  }

  setLoading(false);
};



  // Handle close button
  // const handleCloseButton = () => {
  //   if (!currentSet) return;
  //   const formData = new FormData();
  //   formData.append("data_set_id", currentSet.word_list[0].data_set_id);
  //   formData.append("status", "inprogress");
  //   formData.append("timespent", seconds);
  //   try {
  //     window.wordsearchtimespent(formData);
  //     console.log("Close button: Timespent submitted:", {
  //       data_set_id: currentSet.word_list[0].data_set_id,
  //       status: "inprogress",
  //       timespent: seconds,
  //     });
  //   } catch (err) {
  //     console.error("Error submitting timespent on close:", err);
  //   }
  //   setScreen("title");
  // };
const handleCloseButton = () => {
  if (!currentSet || !startTimeRef.current) return;

  stopTimer(); // âœ… stop timer

  const finalTime = Math.floor((Date.now() - startTimeRef.current) / 1000);

  const formData = new FormData();
  formData.append("data_set_id", currentSet.word_list[0].data_set_id);
  formData.append("status", "inprogress");
  formData.append("timespent", finalTime);

  try {
    window.wordsearchtimespent(formData);
  } catch (err) {
    console.error("Error submitting timespent on close:", err);
  }

  setScreen("title");
};



  useEffect(() => {
    const closeButton = document.getElementById("closing-btn-in-rails");
    if (closeButton) {
      closeButton.addEventListener("click", handleCloseButton);
    }
    return () => {
      if (closeButton) {
        closeButton.removeEventListener("click", handleCloseButton);
      }
    };
  }, [currentSet, ]);

  // const dragCells = useMemo(() => (drag?.active && puzzle ? buildPath(drag.start, drag.end) : []), [drag, puzzle]);
 const dragCells = useMemo(
  () => (drag?.active && puzzle ? buildPath(drag.start, drag.end) : []),
  [drag, puzzle]
);
// const isDraggingHere = dragCells.some(p => p.r === r && p.c === c);
  return (
    <div
      style={{
        width: "100%",
        height: isMobile ? "85vh" : isTablet ? "60vh" : "82vh",
        overflow:isMobile?"scroll": "hidden",
        borderRadius: "10px",
        // background: "linear-gradient(135deg, #ffd6e8, #d6f0ff, #e6ffd6, #fff0d6)",
        backgroundImage:"url(https://d3g74fig38xwgn.cloudfront.net/sound_wall/images/forestBg.jpg)",
        position: "relative",
      }}
      onMouseUp={onUp}
      onTouchEnd={(e) => {
        e.preventDefault();
        onUp();
      }}
    >
      {loading && <Loader />}
      {!loading && !hasValidData && (
        <div
          style={{
            position: "absolute",
            inset: 0,
            display: "grid",
            placeItems: "center",
            background: "rgba(0, 0, 0, 0.7)",
            zIndex: 20,
          }}
        >
          <div
            style={{
              background: "linear-gradient(135deg, #fceabb, #f8b500)",
              padding: 24,
              borderRadius: 16,
              textAlign: "center",
              boxShadow: "0 8px 20px rgba(0,0,0,.15)",
              color: "#333",
            }}
          >
            <h3 style={{ fontSize: 20, fontWeight: "bold", marginBottom: 12 }}>
              No Data Found
            </h3>
            <p style={{ fontSize: 16 }}>
              Sorry, no puzzle data is available at the moment. Please try again later.
            </p>
          </div>
        </div>
      )}
      {!loading && hasValidData && screen === "title" && (
        <TitleScreen
          onStart={() => {
            startTimer();
            setScreen("play");
          }}
        />
      )}
      {!loading && hasValidData && puzzle && currentSet && screen === "play" && (
        <div
          style={{
            position: "relative",
            padding,
            width: "100%",
            height: "100%",
            boxSizing: "border-box",
            display: "flex",
            flexDirection: isMobile ? "column" : "row",
            gap: "1rem",
            justifyContent: isMobile? "start":"center",
            alignItems: "center",
          }}
        >
          {/* <div
          className="border border-red-200"
            style={{
              position: "relative",
              width: isMobile ? "100%" : boardW * 0.8,
              height: isMobile ? "45%" : boardH * 0.8,
              borderRadius: 16,
              background: GRID_TINTS[levelIdx % GRID_TINTS.length],
            }}
            onMouseLeave={() => setDrag(null)}
          >
            <svg
              viewBox={`0 0 ${COLS} ${ROWS}`}
              style={{ position: "", inset: 0, width: "100%", height: "auto", overflow: "visible" }}
              ref={svgRef}
            >
              <defs>
                <linearGradient id="foundGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                  <stop offset="0%" style={{ stopColor: "rgba(22, 163, 74, 0.2)", stopOpacity: 1 }} />
                  <stop offset="100%" style={{ stopColor: "rgba(134, 239, 172, 0.3)", stopOpacity: 1 }} />
                </linearGradient>
              </defs>
              {Array.from({ length: ROWS }).map((_, r) => (
                Array.from({ length: COLS }).map((__, c) => {
                  const isFound = rings.some((ring) => ring.x <= c && c < ring.x + ring.w && ring.y <= r && r < ring.y + ring.h);
                  return (
                    <g key={`cell-${r}-${c}`}>
                      {isFound && (
                        <rect
                          x={c}
                          y={r}
                          width={1}
                          height={1}
                          fill="url(#foundGradient)"
                          stroke="rgba(22, 163, 74, 0.4)"
                          strokeWidth={0.02}
                          rx={0.5}
                          ry={0.5}
                        />
                      )}
                      <text
                        x={c + 0.5}
                        y={r + 0.5}
                        textAnchor="middle"
                        dominantBaseline="middle"
                        style={{
                          fontSize: 0.56,
                          fontWeight: 700,
                          fill: isFound ? "rgb(22, 163, 74)" : "#0f172a",
                        }}
                      >
                        {puzzle.grid[r][c]}
                      </text>
                    </g>
                  );
                })
              ))}
              <g>
                {dragCells.map(({ r, c }, i) => (
                  <rect
                    key={`sel-${r}-${c}-${i}`}
                    x={c + 0.08}
                    y={r + 0.18}
                    width={0.84}
                    height={0.64}
                    rx={0.18}
                    ry={0.18}
                    fill="rgba(22,163,74,0.18)"
                    stroke="rgba(22,163,74,0.6)"
                    strokeWidth={0.06}
                  />
                ))}
              </g>
              <g>
                {Array.from({ length: ROWS }).map((_, r) => (
                  Array.from({ length: COLS }).map((__, c) => (
                    <rect
                      key={`hot-${r}-${c}`}
                      x={c}
                      y={r}
                      width={1}
                      height={1}
                      fill="transparent"
                      onMouseDown={() => onDown(r, c)}
                      onMouseMove={(e) => {
                        if (e.buttons === 1) onEnter(r, c);
                      }}
                      onTouchStart={(e) => {
                        e.preventDefault();
                        onDown(r, c);
                      }}
                      onTouchMove={(e) => {
                        const svg = svgRef.current || e.currentTarget.ownerSVGElement;
                        const box = svg.getBoundingClientRect();
                        const t = e.touches[0];
                        const x = ((t.clientX - box.left) / box.width) * COLS;
                        const y = ((t.clientY - box.top) / box.height) * ROWS;
                        const rr = Math.max(0, Math.min(ROWS - 1, Math.floor(y)));
                        const cc = Math.max(0, Math.min(COLS - 1, Math.floor(x)));
                        onEnter(rr, cc);
                      }}
                    />
                  ))
                ))}
              </g>
            </svg>
          </div> */}
          <div
  className="relative  rounded-xl flex gap-[0.1rem]"
  style={{
    width: isMobile ? "100%" : boardW * 0.8,
    height: isMobile ? "70%" : isTablet ? boardH * 1 :boardH * 0.8,
    // background: GRID_TINTS[levelIdx % GRID_TINTS.length],
    // background: "#F5DEB3",
    backgroundImage:'url(https://d3g74fig38xwgn.cloudfront.net/sound_wall/images/wordBg.jpg)',
    display: "grid",
    gridTemplateColumns: `repeat(${COLS}, 1fr)`,
    gridTemplateRows: `repeat(${ROWS}, 1fr)`,
    padding:'1rem'
  }}
  onMouseLeave={() => setDrag(null)}
>
{Array.from({ length: ROWS }).map((_, r) =>
  Array.from({ length: COLS }).map((__, c) => {
    const isFound = rings.some(
      (ring) =>
        ring.x <= c &&
        c < ring.x + ring.w &&
        ring.y <= r &&
        r < ring.y + ring.h
    );
// console.log(isFound,"isFound")
    // âœ… Now r and c exist here
    const isDraggingHere = dragCells.some(
      (p) => p.r === r && p.c === c
    );

    const letter = puzzle.grid[r][c];

    return (
      <div
        key={`cell-${r}-${c}`}
        className="flex items-center justify-center font-bold border border-white bg-amber-800"
        style={{
          fontSize: "1.5rem",
          borderRadius: "50px",
          userSelect: "none",
          background: isFound
            // ? "linear-gradient(135deg, rgba(22,163,74,0.2), rgba(134,239,172,0.3))"
            ?"#FF8652"
            : isDraggingHere
            // ? "rgba(22,163,74,0.18)"
            ? "yellow"
            : "#a56f2a",
          color: isFound
            // ? "rgb(22, 163, 74)"
            ? "white"
            : isDraggingHere
            // ? "rgb(21, 128, 61)"
             ? "black"
            // : "#0f172a",
            :"white"
        }}
        onMouseDown={() => onDown(r, c)}
        onMouseMove={(e) => {
          if (e.buttons === 1) onEnter(r, c);
        }}
        onTouchStart={(e) => {
          e.preventDefault();
          onDown(r, c);
        }}
        onTouchMove={(e) => {
          const box = e.currentTarget.parentElement.getBoundingClientRect();
          const t = e.touches[0];
          const x = ((t.clientX - box.left) / box.width) * COLS;
          const y = ((t.clientY - box.top) / box.height) * ROWS;
          const rr = Math.max(0, Math.min(ROWS - 1, Math.floor(y)));
          const cc = Math.max(0, Math.min(COLS - 1, Math.floor(x)));
          onEnter(rr, cc);
        }}
      >
        {letter}
      </div>
    );
  })
)}

</div>
  
          <div />
          <aside
            style={{
              width: isMobile ? "90%" : sideW,
              height: isMobile ? "400px" : boardH * 0.8,
              marginTop: isMobile ? 12 : 0,
              // background: "#ffffff",
              backgroundImage:'url(https://d3g74fig38xwgn.cloudfront.net/sound_wall/images/puzzleBg.webp)',
              borderRadius: 16,
              padding: 10,
              boxSizing: "border-box",
              boxShadow: "0 8px 20px rgba(0,0,0,.12)",
              display: "grid",
              gridTemplateRows: "auto 1fr",
            }}
          >
            <div
  style={{
    textAlign: "center",
    fontWeight: 900,
    marginBottom: isTablet? 1:8,
    fontSize:isTablet? '1rem':"1.5rem",
    color: "white",
    width: "100%",
    height: 100, // add height so image is visible
    lineHeight: "80px", // vertically center text
    backgroundImage: 'url(https://d3g74fig38xwgn.cloudfront.net/sound_wall/images/board.png)',
    backgroundSize: "cover", // cover entire div
    backgroundRepeat: "no-repeat",
    backgroundPosition: "center",
  }}
>
  Word Set
 
</div>

            <div style={{
              overflowY: "auto",
              paddingRight: 4,
              maxHeight: "100%",
              scrollbarWidth: "thin",
            }}>
              <style>
                {`
                  div::-webkit-scrollbar {
                    width: 4px;
                  }
                  div::-webkit-scrollbar-track {
                    background: #f0fff4;
                    borderRadius: 8px;
                  }
                  div::-webkit-scrollbar-thumb {
                    background: lightgrey;
                    borderRadius: 8px;
                    border: 2px solid #f0fff4;
                  }
                  div::-webkit-scrollbar-thumb:hover {
                    background: #22c55e;
                  }
                `}
              </style>
              <div style={{ display: "grid", gridTemplateColumns: "1fr", gap: 8 }}>
                {puzzle.words.map((w, i) => (
                  <div
                    key={w}
                    style={{
                      height: 40,
                      display: "grid",
                      placeItems: "center",
                      borderRadius: 12,
                      background: found.has(w) ? "linear-gradient(135deg,#bbf7d0,#86efac)" : CARD_GRADS[i % CARD_GRADS.length],
                      // color: found.has(w) ? "#065f46" : "#0f172a",
                      color: found.has(w) ? "#065f46" : "white",
                      border: found.has(w) ? "2px solid #22c55e" : "2px solid rgba(0,0,0,.06)",
                      fontWeight: 1000,
                      letterSpacing: 1,
                      textShadow: found.has(w) ? "none" : "0 1px 0 rgba(255,255,255,.6)",
                    }}
                  >
                    {w}
                  </div>
                ))}
              </div>
            </div>
          </aside>
          {celebrate && (
            <div style={{ position: "absolute", inset: 0, background: "#000c", display: "grid", placeItems: "center" }}>
              <Confetti />
              <div style={{ position: "relative", display: "grid", gap: 16, placeItems: "center" }}>
                <StarsRow />
                <button
                  onTouchStart={handleNextLevel}
                  onClick={handleNextLevel}
                  style={{
                    padding: "14px 22px",
                    borderRadius: "999px",
                    border: "none",
                    background: "linear-gradient(135deg, #ff9a9e, #fad0c4, #fbc2eb)",
                    color: "#fff",
                    fontWeight: 800,
                    fontSize: "18px",
                    cursor: "pointer",
                    boxShadow: "0 6px 16px rgba(0,0,0,.2)",
                    textShadow: "1px 1px 2px rgba(0,0,0,.3)",
                    transition: "all 0.3s ease",
                  }}
                  onMouseOver={(e) => {
                    e.target.style.transform = "scale(1.1)";
                  }}
                  onMouseOut={(e) => {
                    e.target.style.transform = "scale(1)";
                  }}
                >
                  ðŸŽ‰ Next Level
                </button>
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
